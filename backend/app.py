import os
from flask import Flask, jsonify, request
from flask_sqlalchemy import SQLAlchemy
from flask_cors import CORS
import vanna
from vanna.remote import VannaDefault
import pandas as pd
import duckdb
from flask import request

# Constants
BASE_DIR = os.path.abspath(os.path.dirname(__file__))
DATABASE_URI = f'sqlite:///{os.path.join(BASE_DIR, "chinook.db")}'
SQL_MODEL = 'ai-search'
VANNA_API_KEY = ''
QUERY_ARTISTS = "All artists with name Banda Black Rio"  # Example for artists
QUERY_TRACKS = "All tracks with name Fast As a Shark"  # Example for tracks
QUERY_EMPLOYEES = "All employees in the Sales department"  # Example for employees

# Flask App Setup
app = Flask(__name__)
CORS(app)
app.config['SQLALCHEMY_DATABASE_URI'] = DATABASE_URI
app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False

# Initialize SQLAlchemy and Vanna
db = SQLAlchemy(app)
vn = VannaDefault(model=SQL_MODEL, api_key=VANNA_API_KEY)

# Define models based on Chinook tables
class Artist(db.Model):
    __tablename__ = 'artists'
    ArtistId = db.Column(db.Integer, primary_key=True)
    Name = db.Column(db.String(120))

class Album(db.Model):
    __tablename__ = 'albums'
    AlbumId = db.Column(db.Integer, primary_key=True)
    Title = db.Column(db.String(160))
    ArtistId = db.Column(db.Integer, db.ForeignKey('Artist.ArtistId'))

class Track(db.Model):
    __tablename__ = 'tracks'
    TrackId = db.Column(db.Integer, primary_key=True)
    Name = db.Column(db.String(200))
    AlbumId = db.Column(db.Integer, db.ForeignKey('Album.AlbumId'))
    MediaTypeId = db.Column(db.Integer)
    GenreId = db.Column(db.Integer)
    Composer = db.Column(db.String(220))
    Milliseconds = db.Column(db.Integer)
    Bytes = db.Column(db.Integer)
    UnitPrice = db.Column(db.Float)

# Utility function to query any list and get a DataFrame result
def query_and_get_df(data, query, model_class, query_type):
    """ 
    Generic function to convert model data to DataFrame, generate query with Vanna, 
    and execute it using DuckDB.
    
    :param query: Vanna generated SQL query
    :param model_class: The SQLAlchemy model class (e.g., Artist, Track, etc.)
    :param query_type: Type of data being queried (e.g., 'artist', 'track')
    :return: JSON response from the query result
    """
    # Query the model and load results into a Pandas DataFrame
    data_list = [{column.name: getattr(item, column.name) for column in model_class.__table__.columns} for item in data]
    
    # Dynamically create the variable name for the table (e.g., 'artists', 'tracks', etc.)
    table_name = query_type.lower()  # query_type is passed, and we convert it to lowercase for consistency
    globals()[table_name] = pd.DataFrame(data_list)  # Create a dynamic variable and assign DataFrame to it

    # Connect to Vanna and generate SQL query
    sql_query = vn.generate_sql(query)  # Example query generated by Vanna
    print(f"Generated SQL Query for {query_type}:", sql_query)

    try:
        # Use DuckDB to run the SQL query on the DataFrame
        result_df = duckdb.query(sql_query).df()
        print(f"Query Result for {query_type}:", result_df)
    except Exception as e:
        print(f"Error running query on {query_type} DataFrame:", e)
        result_df = globals()[table_name]  # Fallback to the dynamically created DataFrame if there's an error

    # Convert the result DataFrame back to JSON
    result_data = result_df.to_dict(orient='records')
    return result_data


@app.route('/api/artists', methods=['GET'])
def get_artists():
    result_artists = query_and_get_df(QUERY_ARTISTS, Artist, "artists")
    return jsonify(result_artists)

@app.route('/api/tracks', methods=['GET'])
def get_tracks():
    data = Track.query.all()
    tracks_data = [
            {
                "TrackId": track.TrackId,
                "Name": track.Name,
                "AlbumId": track.AlbumId,
                "MediaTypeId": track.MediaTypeId,
                "GenreId": track.GenreId,
                "Composer": track.Composer,
                "Milliseconds": track.Milliseconds,
                "Bytes": track.Bytes,
                "UnitPrice": track.UnitPrice
            } for track in data
        ]
    query = request.args.get('query', default=None, type=str)
    if not query:
        return jsonify(tracks_data)
    result_tracks = query_and_get_df(data, f"All tracks with {query}", Track, "tracks")
    return jsonify(result_tracks)

if __name__ == '__main__':
    app.run(debug=True)
